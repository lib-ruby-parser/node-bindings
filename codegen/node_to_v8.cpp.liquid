// This file is autogenerated by {{ template }}

#include "lib-ruby-parser.hpp"
#include "to_v8.hpp"

#ifdef LIB_RUBY_PARSER_DEBUG
#include <iostream>
#endif

decl_to_v8_for(lib_ruby_parser::Node *);

{% for node in nodes %}
decl_to_v8_for(lib_ruby_parser::{{ node.camelcase_name }});
template <>
Napi::Value ToV8<lib_ruby_parser::{{ node.camelcase_name }}>(
    lib_ruby_parser::{{ node.camelcase_name }} value,
    Napi::Env &env,
    Napi::Object &objects)
{
#ifdef LIB_RUBY_PARSER_DEBUG
    std::cerr << "ToV8({{ node.camelcase_name }})\n";
#endif
    GetObject({{ node.camelcase_name }});
    return {{ node.camelcase_name }}.New({
        {%- for field in node.fields %}
        ToV8(std::move(value.{{ field.snakecase_name | escape_cpp_keyword }}), env, objects),
        {%- endfor %}
    });
}
{% endfor %}

template <>
Napi::Value ToV8<lib_ruby_parser::Node *>(
    lib_ruby_parser::Node *value,
    Napi::Env &env,
    Napi::Object &objects)
{
#ifdef LIB_RUBY_PARSER_DEBUG
    std::cerr << "ToV8(Node *)\n";
#endif
    if (value == nullptr) {
        return env.Null();
    }
    switch (value->tag)
    {
        {%- for node in nodes %}
        case lib_ruby_parser::Node::Tag::{{ node.camelcase_name | camelcase_to_snakecase | upcase | escape_cpp_keyword }}:
            return ToV8(std::move(value->as.{{ node.camelcase_name | camelcase_to_snakecase | escape_cpp_keyword }}), env, objects);
        {%- endfor %}
    }
#ifdef LIB_RUBY_PARSER_DEBUG
    std::cerr << "Unknown node variant??\n";
#endif
}

template <>
Napi::Value ToV8<lib_ruby_parser::Node>(
    lib_ruby_parser::Node value,
    Napi::Env &env,
    Napi::Object &objects)
{
#ifdef LIB_RUBY_PARSER_DEBUG
    std::cerr << "ToV8(Node *)\n";
#endif
    return ToV8(&value, env, objects);
}
